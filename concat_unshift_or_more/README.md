# 关于性能测试

### 这次测试的由来
我提交作业前看了老师的参考答案，我发现老师使用的方法是`list.unshift(item)`，而我选择的方法是`Array(item).concat(list)`。这让我很好奇，难道老师的unshift会比我的执行效率高吗（其实这一点意义都没有，但是我就是特别好奇）。于是我在写好作业的基础上写了这个所谓的“性能测试”。



### 参与测试的三个方法：
#### unshift
就是按照老师的参考答案来写的`list.unshift(item)`

#### concat
按照我最开始的思路，做一个数组的合并，`Array(item).concat(list)`，生成了一个[item, ... items_of_list]

#### reverse->push->reverse
另一个清奇的思路，先把数组`reverse`，然后再`push`过来，最后再`reverse`回去



### 测试结果
然后，结果让我很意外，十万是个很大的分水岭，素组超过十万个元素后unshift的性能明显好好于其它两个

```text
******************第1次测试开始，本次生成10个样例******************
unshift性能测试
耗费时间(毫秒): 0.384ms
concat性能测试
耗费时间(毫秒): 0.125ms
reverse->push->reverse性能测试
耗费时间(毫秒): 0.170ms
******************第0次测试结束******************


******************第2次测试开始，本次生成100个样例******************
unshift性能测试
耗费时间(毫秒): 0.072ms
concat性能测试
耗费时间(毫秒): 0.070ms
reverse->push->reverse性能测试
耗费时间(毫秒): 0.065ms
******************第1次测试结束******************


******************第3次测试开始，本次生成1000个样例******************
unshift性能测试
耗费时间(毫秒): 0.063ms
concat性能测试
耗费时间(毫秒): 0.072ms
reverse->push->reverse性能测试
耗费时间(毫秒): 0.063ms
******************第2次测试结束******************


******************第4次测试开始，本次生成10000个样例******************
unshift性能测试
耗费时间(毫秒): 0.157ms
concat性能测试
耗费时间(毫秒): 0.164ms
reverse->push->reverse性能测试
耗费时间(毫秒): 0.123ms
******************第3次测试结束******************


******************第5次测试开始，本次生成100000个样例******************
unshift性能测试
耗费时间(毫秒): 1.317ms
concat性能测试
耗费时间(毫秒): 2.065ms
reverse->push->reverse性能测试
耗费时间(毫秒): 3.261ms
******************第4次测试结束******************


******************第6次测试开始，本次生成1000000个样例******************
unshift性能测试
耗费时间(毫秒): 5.075ms
concat性能测试
耗费时间(毫秒): 10.130ms
reverse->push->reverse性能测试
耗费时间(毫秒): 12.165ms
******************第5次测试结束******************
```

### 我的思考

我对这三个方式的性能有了更深的认识和理解

`Array(item).concat(list)`相当于是将这个数组和新生成的数组合并，这样是生成两次数组:
1. list转换为Array,生成了一个只有item一个元素的数组，因为内容少，所以生成速度还算快
1. 生成了`[item, ...]` 这个过程`很耗时`

`reverse(list); list.push(item); reverse(list);`相当于前后生成了两次数组后再push：
1. reverse 生成了一个 `[-1...0]`的数组，这个过程`很耗时`
1. push为数组增加一个新元素 `[-1 ... 0, item]` 这个过程非常快
1. 再次reverse 生成了 `[item, 0, ... -1]` 的数组，这个过程`很耗时`

`list.unshift(item)`它只遍历一次数组：
1. 先将`list.length`增加了1
1. 遍历了一次数组并且还将所有元素后移了一次， 这个过程`非常费时`
1. `list[0] = item` 这个最省时

当元素数量越来越多的时候，`unshift`虽然代价巨大，但是与前两个相比，它只遍历一次元素，且不生成新元素，所以元素超过10万个以后，反而是unshift这种一心一意的方法最快了……
相对的，`reverse->push->reverse`在一万个元素以内的性能是最好的（虽然concat可能在10个的时候测试效果最佳……）……至于`unshift`……我想说果然是越专注，就越能扛起更多责任啊……
